---
title:      iOS面试题答案整理-Swift
date:       2024-04-22
tags:
- iOS
- 面试
--- 

## 1、Swift数据类型，常量、变量、元组

Swift 是一种苹果推出的强类型、编译型的编程语言，用于 iOS，macOS，watchOS 和 tvOS 等应用开发。以下是对 Swift 中的数据类型、常量和变量、以及元组的简要说明：

**数据类型**

Swift 支持多种数据类型，包括整数类型（如 Int、UInt）、浮点数类型（如 Double、Float）、布尔类型（Bool）、字符串类型（String）等等。这些都是基础数据类型，Swift 还支持更复杂的数据类型，如数组（Array）、字典（Dictionary）、集合（Set）、结构体（Struct）、枚举（Enumeration）等。

**常量和变量**

在 Swift 中，常量和变量都用于存储数据。常量存储后其值不可更改，而变量的值可以随时更改。

* 常量：使用 `let` 关键字声明，一旦赋值后就不能再修改。例如：


```swift
let constantValue = 10
```
* 变量：使用 `var` 关键字声明，其值可以在程序运行过程中被修改。例如：


```swift
var variableValue = 20
variableValue = 30  // 之后可以改变变量的值
```
**元组**

元组（Tuples）是 Swift 中一个特殊的复合数据类型，它允许你将多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。你可以通过下标或者命名元素来访问元组中的值。

例如：


```swift
let person = ("John", 30, "Developer")
// 这是一个包含三个元素的元组，分别是一个字符串，一个整数和一个字符串。

// 可以通过下标访问元组中的元素
print(person.0)  // 输出 "John"
print(person.1)  // 输出 30
print(person.2)  // 输出 "Developer"

// 你也可以给元组的每个元素命名，然后通过名字来访问
let httpResponse = (statusCode: 200, description: "OK")
print(httpResponse.statusCode)  // 输出 200
```
以上就是 Swift 中的数据类型、常量和变量以及元组的基本概念。

### 值类型和引用类型区别，swift中值类型有哪些，引用类型有哪些。和OC相比有什么区别？

值类型和引用类型的区别主要在于它们在内存中如何存储和传递数据。以下是它们之间的主要区别，以及在Swift中的具体类型，同时与Objective-C（OC）进行了比较。

**值类型和引用类型的区别：**

1. **存储方式**：值类型直接存储数据值，而引用类型存储的是指向数据值的引用（或指针）。
2. **数据传递**：当值类型的数据被传递时，它会创建一个数据的副本，因此原始数据不会被改变。而引用类型传递的是引用，任何对引用的修改都会影响到原始数据。
3. **内存管理**：值类型通常分配在栈上，效率较高；引用类型分配在托管堆上，需要额外的内存管理。

**Swift中的值类型和引用类型：**

* **值类型**：在Swift中，值类型包括整型（Int）、浮点型（Float、Double）、布尔型（Bool）、字符（Character）、字符串（String，尽管在Swift中String是结构体，但作为值类型表现）、元组、集合类型（如Array、Dictionary、Set）、枚举（enum）和结构体（struct）。这些都是值类型，当它们被赋值或传递时，会创建数据的副本。
* **引用类型**：在Swift中，主要的引用类型是类（class）。与结构体和枚举不同，类可以继承，并且可以有引用类型的属性。

**与Objective-C相比的区别：**

1. **类型安全性**：Swift是类型安全的语言，它强制要求变量和常量的类型明确，这有助于减少运行时错误。相比之下，Objective-C的类型检查较为宽松，有时可能导致类型不匹配的错误在运行时才被发现。
2. **值类型与引用类型的处理**：在Objective-C中，大部分对象都是引用类型，即使是像NSString这样的基本数据类型，也是通过指针来引用的。而在Swift中，许多基本数据类型（如Int、Float、String等）都是值类型，这提供了更好的数据封装和不可变性保证。
3. **内存管理**：Swift使用自动引用计数（ARC）来管理内存，这大大简化了内存管理的复杂性。Objective-C也支持ARC，但开发者仍然需要更谨慎地处理内存管理问题，特别是在处理引用类型和手动内存管理时。
4. **语法简洁性**：Swift的语法更加简洁和现代化，减少了不必要的符号和繁琐的语法结构。这使得Swift代码更加易读和易写。Objective-C的语法则相对复杂一些，特别是在处理指针和引用时。

综上所述，Swift通过强化值类型和引用类型的区别、提供类型安全和简洁的语法等方式，为开发者提供了更高效、更安全的编程体验。

---------------------------------------------------------------------

### Optional可选类型属于引用类型还是值类型？如何实现的

在Swift中，`Optional`是一个枚举类型，它被定义为一个泛型枚举，可以包裹任何类型的值，或者表示没有值（即`nil`）。由于枚举在Swift中是值类型，因此`Optional`本身也是一个值类型。

`Optional`的实现大致如下：

```swift
enum Optional<T> {
    case none
    indirect case some(T)
}
```

这里使用了Swift的枚举和泛型特性。`Optional`枚举有两个可能的案例（case）：`none`表示没有值，对应于`nil`；`some(T)`表示有值，其中`T`是一个泛型参数，代表可以包裹任意类型的值。

由于`Optional`是值类型，当你将一个`Optional`值赋值给另一个变量时，会进行值的拷贝，而不是引用的拷贝。这意味着每个变量都有自己的`Optional`值拷贝，对一个变量的修改不会影响其他变量。

Swift中的`Optional`类型是类型安全的，它要求开发者显式地处理可能的`nil`值，这有助于减少运行时的空指针异常。你可以使用可选绑定（optional binding）或者可选链（optional chaining）来安全地处理`Optional`值。

在实际使用中，Swift提供了语法糖，使得处理`Optional`类型更加简洁。例如，你可以直接使用`?`来表示一个可选类型，如`Int?`表示一个可选的整数类型。此外，Swift还提供了`if let`、`guard let`等语法结构来方便地解包和处理`Optional`值。

总的来说，`Optional`类型是Swift语言特性中的一个重要组成部分，它提供了一种安全的方式来处理可能不存在的值，从而增强了代码的健壮性和可读性。

---------------------------------------------------------------------

### 常量和变量分别如何声明？

在Swift中，常量和变量的声明方式略有不同。

**常量声明**：
常量使用关键字`let`来声明，它表示这个值在赋值后就不能再被修改。常量的命名应该使用全部大写字母或者驼峰式命名法来表示它是一个常量，但这并不是强制的，只是一种编程习惯。常量的声明语法如下：

```swift
let constantName = value
```

例如，声明一个常量并给它赋值：

```swift
let PI = 3.14159
```

**变量声明**：
变量使用关键字`var`来声明，它表示这个值在程序运行过程中可以被重新赋值。变量的声明语法如下：

```swift
var variableName: DataType = initialValue
```

这里的`DataType`是可选的，Swift 的类型推断机制会自动推断出变量的类型。例如，声明一个变量并给它赋值：

```swift
var score = 85
```

在这个例子中，Swift 可以自动推断出`score`的类型是`Int`，因此无需显式指定类型。

如果需要在声明时明确指定变量的类型，可以这样做：

```swift
var age: Int = 25
var name: String = "Alice"
```

另外，Swift 也支持在声明变量时省略初始值，但此时必须显式指定变量的类型，例如：

```swift
var height: Float // 必须在后续代码中给height赋值
```

总结一下，`let`用于声明常量，其值在初始化后不能被修改；`var`用于声明变量，其值可以被修改。在声明时可以指定数据类型，也可以通过赋值让Swift自动推断数据类型。

---------------------------------------------------------------------

### 可选类型解包方式有哪些？

在Swift中，可选类型的解包主要有以下几种方式：

1. **强制解包（Forced Unwrapping）**：
   当确定可选类型中确实包含值时，可以使用感叹号（!）进行强制解包。例如：
   ```swift
   let optionalString: String? = "Hello, Swift!"
   let unwrappedString: String = optionalString! // 强制解包
   ```
   需要注意的是，如果尝试对一个值为`nil`的可选类型进行强制解包，将会导致运行时错误。

2. **可选绑定（Optional Binding）**：
   使用`if let`或`guard let`语句来安全地解包可选类型。如果可选类型有值，则将其解包并赋值给一个新的常量或变量，同时执行相应的代码块。例如：
   ```swift
   let optionalString: String? = "Hello, Swift!"
   if let unwrappedString = optionalString {
       print(unwrappedString) // 输出解包后的字符串
   } else {
       print("Optional string is empty")
   }
   ```
   这种方式比较安全，因为在可选类型为`nil`时不会尝试解包，从而避免了运行时错误。

3. **隐式解包可选类型（Implicitly Unwrapped Optionals）**：
   在某些情况下，可以声明一个隐式解包可选类型，这样在使用时就不需要每次都进行解包操作。这种类型的变量在声明时使用两个感叹号（!!）来表示。例如：
   ```swift
   let implicitlyUnwrappedString: String!! = "Hello, Swift!"
   print(implicitlyUnwrappedString) // 直接使用，无需解包
   ```
   但请注意，隐式解包可选类型仍然是一个可选类型，如果其值为`nil`，在访问时仍会导致运行时错误。因此，应谨慎使用隐式解包可选类型。

4. **Nil合并运算符（Nil-Coalescing Operator）**：
   Swift还提供了Nil合并运算符`??`，用于在可选类型为`nil`时提供一个默认值。例如：
   ```swift
   let optionalString: String? = nil
   let unwrappedString = optionalString ?? "default value" // 如果optionalString为nil，则使用"default value"
   print(unwrappedString) // 输出"default value"
   ```

在实际编程中，应根据具体场景和需求选择合适的可选类型解包方式。在大多数情况下，推荐使用可选绑定（`if let`或`guard let`）来安全地处理可选类型。

### 什么是可选和解包？

在 Swift 中，可选（Optional）是一个特殊的类型，用于表示某个值可能存在，也可能不存在。Swift 引入可选类型主要是为了增强代码的安全性，避免在值不存在时出现运行时错误。

**可选类型**：
在 Swift 中，如果一个变量可能有一个值，也可能没有值（即为 `nil`），那么这个变量就可以被声明为可选类型。可选类型在类型后面添加一个问号（?）来表示，如 `Int?`、`String?` 等。这意味着这个变量可以存储其对应类型的值，或者存储 `nil`。

**解包（Unwrapping）**：
由于可选类型可以包含 `nil`，因此在使用可选类型中的值之前，需要检查它是否为 `nil`。这个过程称为解包。解包就是获取可选类型中实际值的过程。

Swift 提供了几种解包可选类型的方法：

1. **强制解包（Forced Unwrapping）**：
   当你确定一个可选类型实际上包含一个值时，你可以使用 `!` 来进行强制解包。例如，如果你有一个 `String?` 类型的变量 `optionalString`，并且你确定它不是 `nil`，你可以通过 `optionalString!` 来获取其包含的字符串值。但如果 `optionalString` 是 `nil`，使用强制解包会导致运行时错误。

2. **可选绑定（Optional Binding）**：
   使用 `if let` 或 `guard let` 可以更安全地解包可选类型。这种方式会检查可选类型是否有值，并将其解包到一个新的变量中。如果可选类型有值，则执行相应的代码块；如果没有值（即 `nil`），则不执行。这是处理可选类型的推荐方法，因为它避免了强制解包可能带来的风险。

3. **隐式解包可选类型（Implicitly Unwrapped Optionals）**：
   Swift 也支持隐式解包的可选类型，这种类型在声明时在类型后面加两个感叹号（如 `String!!`）。这种类型被假定为在第一次使用时已经初始化，并在之后的使用中无需再次解包。然而，如果尝试在值为 `nil` 时访问它，仍然会导致运行时错误。需要注意的是，现在 Swift 中更推荐使用普通的可选类型和可选绑定，而不是隐式解包的可选类型，因为后者可能导致意外的运行时错误。

4. **Nil合并运算符（Nil-Coalescing Operator）**：
   使用 `??` 运算符可以为可选类型提供一个默认值。如果可选类型有值，则使用该值；如果可选类型是 `nil`，则使用默认值。这是一种简洁的方式来处理可选类型可能为空的情况。

总的来说，可选和解包是 Swift 中处理值可能不存在的情况的重要机制，它们增加了代码的健壮性和安全性。

---------------------------------------------------------------------

### 多重可选项的情况是怎么处理的？

多重可选项是Swift中的一个相对复杂的概念，它指的是一个可选类型的变量本身又是另一个可选类型。处理多重可选项时，需要逐层解包以获得实际的值。以下是处理多重可选项的几种方法：

1. **强制解包（Forced Unwrapping）**:
   对于多重可选项，可以通过连续使用`!`操作符进行强制解包，但这种方法风险较高，因为如果任何一层的可选项为`nil`，都会导致运行时错误。例如，对于`var multiOptional: Int??`，可以通过`multiOptional!!`来强制解包，但通常不推荐这种做法，除非非常确定可选项中确实有值。

2. **可选绑定（Optional Binding）**:
   使用`if let`或`guard let`进行逐层解包是更安全的方法。通过这种方法，可以在解包的同时检查每一层可选项是否有值。例如：

   ```swift
   if let firstLevel = multiOptional, let secondLevel = firstLevel {
       // 使用secondLevel变量，它现在是解包后的值
   }
   ```

3. **空合并运算符（Nil-Coalescing Operator）**:
   对于多重可选项，空合并运算符`??`可以用来提供默认值，但需要对每一层可选项分别使用。例如：

   ```swift
   let unwrappedValue = multiOptional ?? (第二层默认值) ?? (最终默认值)
   ```

   但这种方法在处理多重可选项时可能会变得复杂，因为它需要为每个层级指定默认值。

4. **隐式解包可选类型（Implicitly Unwrapped Optionals）**:
   在某些情况下，如果确定一个多重可选项在初始化后总会有值，可以将其定义为隐式解包的可选类型。但这种方法需要谨慎使用，因为它会增加运行时出错的可能性。

5. **使用flatMap或compactMap**:
   对于多重可选项的数组或其他集合类型，可以使用`flatMap`或`compactMap`来简化处理。这些方法允许你在一个步骤中处理可选性和转换值。
   当处理一个包含可选值的数组或其他集合时，`flatMap` 和 `compactMap`（在 Swift 4.1 之前叫做 `flatMap`，但后来为了避免与 `flatMap` 方法在信号处理和函数式编程中的用法混淆，Swift 团队将其重命名为 `compactMap`）是非常有用的。这两个方法都可以用来处理集合中的可选值，但它们的行为有所不同。

    首先，我们来详细解释一下这两个方法：

- **compactMap**

    `compactMap` 用于将一个集合中的每个元素通过一个闭包进行转换，并只收集那些非可选（即非 `nil`）的结果。它特别适合处理返回可选值的闭包，因为它会自动过滤掉 `nil` 值。

    例如，假设你有一个整数数组，你想要得到一个包含这些整数对应字符串表示的新数组，但并不是所有的整数都能成功转换为字符串（为了示例，我们假设 `convertToIntString` 函数对某些整数返回 `nil`）：

    ```swift
    let integers = [1, 2, 3, 4, 5, 6]

    func convertToIntString(_ number: Int) -> String? {
        // 假设这个函数对于大于 3 的数返回 nil
        return number > 3 ? nil : "\(number)"
    }

    let strings = integers.compactMap { convertToIntString($0) }
    // 结果是 ["1", "2", "3"]，因为只有这些数字能够成功转换为字符串
    ```

    在这个例子中，`compactMap` 过滤掉了所有 `convertToIntString` 返回 `nil` 的情况，只保留了成功转换的字符串。

- **flatMap**

    `flatMap` 在 Swift 的早期版本中与 `compactMap` 有相似的功能，但现在它更常用于将集合中的元素转换为另一个集合，并将这些集合“扁平化”为一个单一的集合。在处理多重可选项时，它不是最直接的选择，但在某些情况下仍然很有用。

    如果我们有一个包含可选数组的数组（即多重可选的集合），我们可以使用 `flatMap` 来“扁平化”它，但通常这需要两步操作：首先解包可选层，然后扁平化结果。

    例如：

    ```swift
    let nestedOptionalArrays: [[Int]?] = [[1, 2, 3], nil, [4, 5, 6]]

    let flattened = nestedOptionalArrays.flatMap { $0 ?? [] }
    // 结果是 [1, 2, 3, 4, 5, 6]，nil 值被替换为了空数组 []
    ```

    在这个例子中，`flatMap` 遍历了包含可选数组的数组，并将每个可选数组解包（使用 `??` 运算符提供一个空数组作为 `nil` 值的默认值），然后将所有非空数组的元素合并到一个新数组中。


- **处理多重可选项的数组**

    如果你有一个多重可选项的数组（例如 `[T??]`），你可以结合使用 `compactMap` 和可选绑定来处理它：

    ```swift
    let multiOptionals: [Int??] = [1, nil, 3, nil, 5]

    let unwrappedValues = multiOptionals.compactMap { $0 }.compactMap { $0 }
    // 结果是 [1, 3, 5]，所有 nil 值都被过滤掉了
    ```

    在这个例子中，我们首先使用 `compactMap` 来解包外层可选，然后对结果再次使用 `compactMap` 来解包内层可选。这样，我们就得到了一个只包含非可选值的数组。

    总的来说，`compactMap` 和 `flatMap` 是处理集合中可选值的强大工具，它们可以帮助你简化代码并避免显式地处理每个可选值。在处理多重可选项时，你可能需要结合使用这两个方法或其他技术来逐层解包可选值。

6. **扩展方法和自定义操作符**:
   为了简化多重可选项的处理，可以定义扩展方法或自定义操作符来封装常见的解包逻辑。

在处理多重可选项时，应优先考虑安全性和清晰性。通常推荐使用可选绑定来处理多重可选项，因为它在解包前会检查每一层是否有值，从而避免运行时错误。同时，合理设计代码结构以减少多重可选项的使用也是一个好的实践。

---------------------------------------------------------------------

### 什么是可选链？可选链的结果是可选项么？

**可选链**是Swift特有的一种语法格式，允许请求和调用可能为nil的属性、方法及下标脚本的过程。如果可判断的目标有值，则调用会成功；如果目标为nil，则调用会返回nil。多次请求或调用可以链接在一起，形成一个链，其中任何一个节点为nil都会导致整个链失效。

关于可选链的结果，具体归纳如下：

1. **可选链的结果是可选项**：即使要查询的属性、方法或下标返回非可选值，通过可选链接调用得到的结果也总是一个可选值。这样做是为了反映可以在nil值上调用可选链接的事实。

2. **返回值的类型**：可选链接调用的结果与预期返回值的类型相同，但会被包含在可选项中。这意味着，如果原本的属性或方法返回一个Int类型，那么通过可选链调用后，返回的结果将是Int?类型。

3. **nil的处理**：在可选链中，如果某个节点为nil，则整个表达式的结果也会是nil。这种特性允许开发者在不确定某个对象是否存在时，依然能够安全地尝试访问其属性或方法。

总的来说，可选链是Swift中一种强大的语法特性，它允许开发者在不确定对象是否为nil的情况下，安全地访问其属性和方法。同时，通过可选链得到的结果总是一个可选值，这增加了代码的安全性和健壮性。

---------------------------------------------------------------------

### 什么是元组，元组能做什么？

在Swift中，元组是一种非常实用的数据结构，它允许你将多个值（可以是不同类型）组合成一个单一的复合值。以下是一些Swift中元组的用法举例：

### 1. 创建元组

你可以使用括号来创建一个元组，元组内的值可以是任意类型，并且不必是统一类型。例如：


```swift
let person = ("Alice", 25, "New York")
```
这里创建了一个包含字符串、整数和另一个字符串的元组。

### 2. 命名元组元素

你可以给元组的每个元素命名，以增加代码的可读性。例如：


```swift
let person = (name: "Alice", age: 25, city: "New York")
```
### 3. 访问元组元素

你可以通过下标或元素名称来访问元组中的值。例如：


```swift
print(person.name)  // 输出 "Alice"
print(person.1)     // 输出 25
```
### 4. 修改可变元组

使用`var`关键字创建的元组是可变的，你可以修改其元素的值，但不能改变元素的类型或增加/删除元素。例如：


```swift
var mutablePerson = (name: "Alice", age: 25, city: "New York")
mutablePerson.age = 26
```
### 5. 元组作为函数返回值

函数可以返回一个元组，从而返回多个值。例如：


```swift
func getPersonInfo() -> (name: String, age: Int, city: String) {
    return ("Alice", 25, "New York")
}
let personInfo = getPersonInfo()
print(personInfo.name) // 输出 "Alice"
```
### 6. 元组解构

你可以将元组中的值解构为单独的常量或变量。例如：


```swift
let (name, age, city) = person
print(name) // 输出 "Alice"
```
如果只需要解构部分值，可以使用下划线`_`来忽略不需要的值。例如：


```swift
let (_, age, _) = person
print(age) // 输出 25
```
### 7. 比较元组

你可以使用`==`和`!=`运算符来比较两个元组是否相等。例如：


```swift
let person1 = ("Alice", 25, "New York")
let person2 = ("Bob", 30, "Los Angeles")
if person1 == person2 {
    print("The two persons are the same")
} else {
    print("The two persons are different") // 输出这一行
}
```
这些就是Swift中元组的一些基本用法。元组提供了一种简单而灵活的方式来组合和处理多个相关的值。

**元组（Tuple）是一种数据结构**，它是一个包含多个元素的不可变序列，通常用于存储一组相关的值。这些值可以是不同类型的数据，例如整数、浮点数、字符串等。元组使用圆括号“()”来表示，元素之间使用逗号分隔。

元组的主要特点和用途包括：

1. **不可变性**：与列表不同，元组一旦创建就不能被修改。这意味着元组中的元素不能被添加、删除或更改。这种特性使得元组在某些情况下比列表更加安全，因为可以确保数据在元组创建后不会被意外修改。
2. **轻量级数据结构**：由于元组是不可变的，因此它们在某些情况下比列表更加轻量级。当需要存储一组不可变的数据时，使用元组可能比使用列表更加高效。
3. **多个值的返回**：在函数中，当需要返回多个值时，可以使用元组。例如，一个函数可以返回一个包含两个整数的元组，表示一个点的x和y坐标。这种方式比单独返回一个复杂的数据结构或对象更加简洁和高效。
4. **用作字典的键**：由于元组是不可变的，因此它们可以用作字典的键。这使得元组在需要快速查找和访问特定数据时非常有用。
5. **数据解包**：元组支持数据解包，这意味着可以从元组中提取出各个元素并分别赋值给不同的变量。这种特性在处理多个相关值时非常方便。

总的来说，元组是一种简单、高效且安全的数据结构，适用于存储和处理一组相关的、不可变的数据。

---------------------------------------------------------------------

### 什么是字面量，字面量协议可以做什么？

在Swift中，字面量（Literal）指的是源代码中直接表示值的一种记法。比如，数字42、字符串"Hello, World!"或布尔值true，这些都是字面量。字面量提供了一种快捷、直观的方式来表示和初始化数据。

Swift中的字面量协议（Literal Protocols）允许开发者为自定义类型定义字面量初始化方法，从而可以使用类似字面量的语法来创建这些类型的实例。Swift标准库中的许多类型，如`Int`、`String`、`Array`等，都实现了相应的字面量协议，使得我们可以直接使用字面量语法来创建这些类型的实例。

字面量协议主要定义了一组用于创建类型实例的静态方法。例如，`ExpressibleByIntegerLiteral`协议定义了一个方法`init(integerLiteral:)`，允许我们使用整数字面量来初始化遵循该协议的类型。类似地，还有其他字面量协议，如`ExpressibleByFloatLiteral`、`ExpressibleByStringLiteral`等。

通过实现这些字面量协议，我们可以为自定义类型提供与内置类型相似的字面量初始化语法。这在创建简洁易读的代码时非常有用。

以下是一个简单的示例，展示了如何为一个自定义类型实现字面量协议：


```swift
struct Point {
    let x: Int
    let y: Int
}

extension Point: ExpressibleByIntegerLiteral {
    init(integerLiteral value: Int) {
        self.x = value
        self.y = value
    }
}

// 使用字面量语法创建Point实例
let p: Point = 42 // 等同于 Point(integerLiteral: 42)
```
在这个示例中，我们定义了一个表示二维点的`Point`结构体，并为其扩展了`ExpressibleByIntegerLiteral`协议。现在，我们可以使用整数字面量来创建`Point`实例，其中x和y坐标都被设置为该整数值。

需要注意的是，虽然字面量协议提供了便捷的初始化方法，但过度使用可能会导致代码可读性降低。因此，在实现自定义字面量初始化方法时，应确保它们在上下文中具有明确和直观的含义。

---------------------------------------------------------------------

## 2、Swift流程控制

在Swift中，流程控制是用于管理代码执行顺序的机制。它允许程序根据特定条件选择性地执行代码块，或者在满足某些条件时重复执行代码。Swift中的流程控制结构包括条件语句（如`if`，`guard`，`switch`）和循环语句（如`for`，`while`）。

### 条件语句

1. **if 语句**


```swift
let number = 10
if number > 5 {
    print("Number is greater than 5")
} else if number == 5 {
    print("Number is equal to 5")
} else {
    print("Number is less than 5")
}
```
2. **guard 语句**

`guard`语句用于提前退出作用域，如果条件不满足，则执行`else`块中的代码。这通常用于在函数或方法中提前处理不满足条件的情况。


```swift
func greet(person: String?) {
    guard let person = person else {
        print("No person provided")
        return
    }
    print("Hello, \(person)!")
}
```
3. **switch 语句**

`switch`语句用于基于不同的情况执行不同的代码块。Swift中的`switch`非常强大，可以匹配多种模式和条件。


```swift
let vegetable = "carrot"
switch vegetable {
case "carrot":
    print("It's a carrot.")
case "potato":
    print("It's a potato.")
default:
    print("It's some other vegetable.")
}
```
### 循环语句

1. **for 循环**

Swift中的`for`循环通常与范围或集合一起使用，用于迭代一系列值。


```swift
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}
```
2. **while 循环**

`while`循环用于在条件为真时重复执行代码块。


```swift
var index = 0
while index < 5 {
    print("\(index + 1) times 5 is \(5 * (index + 1))")
    index += 1
}
```
3. **repeat-while 循环**

Swift也支持`repeat-while`循环，它至少会执行一次循环体，然后在循环体结束后检查条件。这与其他语言中的`do-while`循环类似。在Swift 4及更高版本中，你可以使用`repeat`关键字配合`while`来实现这一功能。但在更早期的Swift版本中，你可能需要手动编写一个类似的循环结构。

### 示例（Swift 4及更高版本）:


```swift
var index = 0
repeat {
    print("\(index + 1) times 5 is \(5 * (index + 1))")
    index += 1
} while index < 5
```
### 示例（早期Swift版本）:

在早期版本的Swift中，没有内置的`repeat-while`语法，但你可以通过其他方式实现相同的效果。


```swift
var index = 0
do {
    print("\(index + 1) times 5 is \(5 * (index + 1))")
    index += 1
} while index < 5
```
注意：在早期Swift版本中，`do`关键字仅用于错误处理，并不直接支持`do-while`循环。因此，上面的示例仅用于说明如何在没有内置`repeat-while`的情况下模拟该行为。在实际的早期Swift版本中，你可能需要使用其他循环结构（如`while`循环配合适当的条件检查）来达到相同的效果。

总的来说，Swift的流程控制结构提供了灵活而强大的方式来控制程序的执行流程。你可以根据需要使用这些结构来编写清晰、高效的代码。

### for in 在Swift上有什么特点？

在Swift中，`for-in`循环是用于遍历集合（如数组、字典、范围、字符串等）中每个元素的便捷方式。以下是`for-in`循环在Swift上的一些特点：

1. **简洁性**：`for-in`循环提供了一种非常简洁的语法来迭代集合中的每个元素，而不需要显式地管理索引或迭代器。
```swift
let fruits = ["Apple", "Banana", "Cherry"]
for fruit in fruits {
    print(fruit)
}
// 输出:
// Apple
// Banana
// Cherry
```
在这个例子中，我们直接遍历了`fruits`数组，没有使用额外的索引或迭代器。

2. **类型推断**：在`for-in`循环中，Swift可以自动推断出集合中元素的类型，因此在循环体内可以直接使用该类型的变量，而无需显式类型转换。
```swift
let scores = [85, 90, 78, 92]
for score in scores {
    print("The score is \(score)")
}
// 输出:
// The score is 85
// The score is 90
// The score is 78
// The score is 92
```
Swift自动推断出`scores`数组中的元素是整数类型，因此我们可以在循环中直接使用整数变量`score`。

3. **只读性**：默认情况下，`for-in`循环提供的迭代变量是只读的，也就是说你不能在循环体内修改这个变量的值。这有助于防止意外的数据修改。
```swift
let cities = ["New York", "London", "Paris"]
for city in cities {
    // city = "Tokyo" // 编译错误，因为city是只读的
    print(city)
}
```
在`for-in`循环中，`city`是一个只读变量，不能被重新赋值。

4. **灵活性**：`for-in`循环可以用于遍历数组、字典、集合、字符串、范围等任何遵循`Sequence`协议的类型。
```swift
let range = 1...5
for number in range {
    print(number)
}
// 输出:
// 1
// 2
// 3
// 4
// 5
```
这里我们遍历了一个范围（Range），展示了`for-in`不仅可以用于数组，还可以用于其他遵循`Sequence`协议的类型。

5. **索引和元素同时遍历**：如果你需要访问当前元素的索引，可以使用`enumerated()`方法来同时获取索引和元素。
```swift
let colors = ["Red", "Green", "Blue"]
for (index, color) in colors.enumerated() {
    print("Color at index \(index) is \(color)")
}
// 输出:
// Color at index 0 is Red
// Color at index 1 is Green
// Color at index 2 is Blue
```
使用`enumerated()`方法可以同时获取元素的索引和值。

6. **与`where`子句结合使用**：可以在`for-in`循环中使用`where`子句来添加条件，以便只迭代满足特定条件的元素。
```swift
let numbers = [1, 2, 3, 4, 5, 6]
for number in numbers where number % 2 == 0 {
    print(number)
}
// 输出:
// 2
// 4
// 6
```
这里我们只遍历并打印了偶数元素。

7. **性能优化**：`for-in`循环在Swift中通常会被编译器优化，以提供高效的迭代性能。

8. **链式调用**：你可以对集合使用链式调用（如`map`、`filter`等），然后再对结果进行`for-in`循环遍历。
```swift
let numbers = [1, 2, 3, 4, 5, 6]
let evenNumbers = numbers.filter { $0 % 2 == 0 }
for number in evenNumbers {
    print(number)
}
// 输出:
// 2
// 4
// 6
```
在这个例子中，我们先对数组进行了过滤操作，只保留了偶数，然后对过滤后的结果进行了遍历。这展示了如何在使用`for-in`之前对集合进行链式调用处理。

总的来说，`for-in`循环在Swift中提供了一种简洁、高效且灵活的方式来遍历集合中的元素。

---------------------------------------------------------------------

### 什么是区间类型？跨间隔的区间怎么实现？

在 Swift 中，区间类型通常指的是表示一系列连续值的范围。Swift 提供了几种区间运算符来创建不同类型的区间：

1. 闭区间运算符（...）：包含区间内的所有值。
2. 半开区间运算符（..<）：包含区间的起始值，但不包含结束值。

例如：

```swift
let closedRange = 1...5  // 闭区间，包含 1, 2, 3, 4, 5
let halfOpenRange = 1..<5  // 半开区间，包含 1, 2, 3, 4，但不包含 5
```

对于“跨间隔”的区间，如果你的意思是指创建一个不是从最小到最大连续递增的区间，而是包含一些间隔或特定值的集合，那么 Swift 本身并没有直接提供一个内置的“跨间隔区间”类型。不过，你可以使用数组或者其他集合类型来表示这样的非连续区间。

例如，你可以创建一个数组，其中包含了你想表示的非连续值：

```swift
let customRange: [Int] = [1, 3, 5, 7, 9]  // 自定义的跨间隔整数数组
```

如果你想要一个更为动态的结构来表示跨间隔的区间，并且希望它支持类似区间的操作（比如包含检查、迭代等），你可能需要自己定义一个结构体或类来实现这样的功能。

以下是一个简单的例子，展示如何定义一个表示跨间隔区间的结构体：

```swift
struct CustomInterval<T: Comparable> {
    let values: [T]
    
    init(values: [T]) {
        self.values = values.sorted()
    }
    
    func contains(_ value: T) -> Bool {
        return values.contains(value)
    }
    
    // 可以根据需要添加更多功能和操作
}

// 使用示例：
let customInterval = CustomInterval(values: [1, 3, 5, 7, 9])
print(customInterval.contains(3)) // 输出: true
print(customInterval.contains(4)) // 输出: false
```

在这个例子中，`CustomInterval` 结构体持有一个泛型类型 `T` 的数组，并且要求 `T` 是可比较的（遵循 `Comparable` 协议）。这个结构体可以根据需要扩展更多的功能，比如迭代、求并集、交集等操作。

---------------------------------------------------------------------

### Swift中switch怎么实现贯穿效果？复合条件或fallthrouh

在 Swift 中，`switch` 语句用于基于不同的条件执行不同的代码块。Swift 的 `switch` 语句非常强大，因为它不仅限于整数值，还可以用于匹配枚举、字符串、元组等多种数据类型。而且，Swift 中的 `switch` 语句必须覆盖所有可能的情况，除非使用 `default` 分支来处理未明确匹配的情况。

要实现“贯穿效果”（fallthrough），即一个 `case` 分支执行完毕后不退出 `switch` 语句，而是继续执行下一个 `case` 分支的代码，你可以使用 `fallthrough` 关键字。这在 C 和 Objective-C 的 `switch` 语句中是默认行为，但在 Swift 中需要显式指定。

下面是一个使用 `fallthrough` 关键字的示例：


```swift
let number = 2

switch number {
case 1:
    print("One")
    fallthrough // 这里会继续执行下面的 case 分支
case 2:
    print("Two")
    fallthrough // 还可以继续贯穿到下一个 case，如果有的话
case 3:
    print("Three")
    // 注意，这里没有 fallthrough，所以执行完这个分支后会退出 switch 语句
default:
    print("Other")
}
```
在这个例子中，当 `number` 等于 2 时，会先打印 "Two"，然后由于 `fallthrough` 关键字的存在，会继续执行下一个 `case` 分支的代码，因此紧接着会打印 "Three"。如果没有 `fallthrough`，则只会执行与 `number` 值匹配的 `case` 分支。

请注意，`fallthrough` 通常用于整数或枚举等可以排序和比较的数据类型。对于其他类型（如字符串或自定义对象），使用 `fallthrough` 可能没有太大意义，因为这些类型的值通常没有自然的排序或连续性。此外，过度使用 `fallthrough` 可能会导致代码难以阅读和维护，因此应谨慎使用。

---------------------------------------------------------------------

### switch与元组结合有什么效果？元组与where结合呢？

在 Swift 中，`switch` 语句与元组结合使用可以提供非常强大的模式匹配功能。你可以在 `switch` 语句中使用元组来匹配多个值，并根据这些值执行不同的代码块。这在处理多个相关值时特别有用，比如处理坐标点、范围或者多个相关状态。

以下是一个 `switch` 语句与元组结合的示例：

```swift
let point = (3, 5)

switch point {
case (0, 0):
    print("(0, 0) is the origin.")
case (_, 0):
    print("Y-coordinate is zero.")
case (0, _):
    print("X-coordinate is zero.")
case (-10...10, -10...10):
    print("Point is within a 20x20 grid centered on the origin.")
default:
    print("Point is outside the defined range.")
}
```

在这个例子中，我们根据点的坐标 `(x, y)` 执行不同的操作。我们可以匹配具体的坐标点，也可以使用 `_` 来忽略某个坐标的值，或者使用范围来匹配一系列坐标。

另一方面，`where` 关键字在 Swift 中通常与 `guard`、`if`、`for` 循环等结合使用来进行条件判断。然而，在 `switch` 语句的 `case` 中，你也可以使用 `where` 子句来对元组或其他匹配条件进行进一步的筛选。

以下是一个 `switch` 语句中使用 `where` 与元组结合的示例：

```swift
let anotherPoint = (2, 4)
let isPositiveY = anotherPoint.1 > 0

switch anotherPoint {
case let (x, y) where y > 0 && x > 0:
    print("Point is in the first quadrant.")
case let (_, y) where y > 0:
    print("Point has a positive Y-coordinate.")
case let (x, _) where x < 0 && isPositiveY:
    print("X is negative and Y is positive (external condition).")
default:
    print("Point does not meet any specific quadrant criteria.")
}
```

在这个例子中，我们使用 `where` 子句来进一步定义当元组中的值满足特定条件时应该执行哪个 `case`。注意，在 `where` 子句中，你可以引用 `switch` 语句外部定义的变量（如示例中的 `isPositiveY`），这使得条件判断更加灵活。

总的来说，`switch` 与元组的结合提供了强大的多值匹配能力，而 `where` 子句则允许你对这些匹配进行更精细的控制。

---------------------------------------------------------------------

### switch区间匹配？

在 Swift 中，如果你想使用 `switch` 语句来进行区间匹配，你可以利用模式匹配结合范围运算符来实现。Swift 提供了闭区间运算符 `...` 和半开区间运算符 `..<` 来定义范围。

下面是一个使用 `switch` 语句进行区间匹配的示例：

```swift
let value = 42

switch value {
case 0...10:
    print("Value is between 0 and 10.")
case 11...20:
    print("Value is between 11 and 20.")
case 21...30:
    print("Value is between 21 and 30.")
case 31...40:
    print("Value is between 31 and 40.")
case 41...50:
    print("Value is between 41 and 50.")
default:
    print("Value is outside the defined ranges.")
}
```

在这个例子中，`value` 变量会与每个 `case` 语句中定义的区间进行比较。当 `value` 落在某个区间内时，相应的 `case` 分支会被执行。

你也可以混合使用具体的值和区间进行匹配：

```swift
let age = 25

switch age {
case 0...18:
    print("You are a minor.")
case 19...64:
    print("You are an adult.")
case 65...:
    print("You are a senior.")
default:
    print("Invalid age.")
}
```

在这个例子中，我们定义了三个年龄段：未成年（0-18岁）、成年人（19-64岁）和老年人（65岁及以上）。注意最后一个区间 `65...` 是一个半开放区间，表示 65 岁及以上的所有年龄。

Swift 的 `switch` 语句非常灵活，允许你根据需要进行复杂的模式匹配，包括区间匹配、元组匹配、特定值匹配等。

---------------------------------------------------------------------

### guard..else与do..while有什么区别

在 Swift 中，`guard` 和 `do...while` 是两种完全不同的控制流结构，它们各自有其特定的用途和行为。

1. `guard...else`:

`guard` 语句用于提前退出当前作用域（例如函数、方法或循环），如果某个条件不满足的话。这通常用于验证函数参数或执行一些必要的先决条件检查。如果 `guard` 语句中的条件为 `false`，则执行 `else` 块中的代码，并且会立即退出当前的作用域。这可以避免嵌套过深的 `if` 语句，使代码更加清晰易读。

示例：

```swift
func greet(person: String?) {
    guard let name = person else {
        print("No name provided.")
        return
    }
    print("Hello, \(name)!")
}

greet(person: "Alice") // 输出: Hello, Alice!
greet(person: nil)     // 输出: No name provided.
```

在这个例子中，`guard` 语句检查 `person` 是否为 `nil`。如果是 `nil`，则执行 `else` 块中的代码并退出函数。

2. `do...while`:

Swift 中实际上并没有内置的 `do...while` 循环结构，与其他一些编程语言不同（如 Java 或 C#）。在 Swift 中，你可以使用 `repeat...while` 来实现类似的功能，但从 Swift 3.0 开始，`repeat...while` 已经被重命名为 `do...while` 以与其他编程语言保持一致。

`do...while` 循环会先执行一次循环体，然后在循环体执行完毕后检查条件。如果条件为 `true`，则循环继续；如果为 `false`，则循环终止。

示例：

```swift
var counter = 0
repeat { // 或者使用 do { 在 Swift 3.0+
    print(counter)
    counter += 1
} while counter < 5
// 输出: 0, 1, 2, 3, 4
```

这个例子中，循环会打印出从 0 到 4 的数字，因为当 `counter` 达到 5 时，条件变为 `false`，循环终止。

总的来说，`guard...else` 主要用于条件检查和提前退出作用域，而 `do...while`（或 `repeat...while`）是一个循环结构，用于重复执行代码块直到满足某个条件为止。

---------------------------------------------------------------------

## 3、Swift结构体，类，枚举

在 Swift 中，结构体（`struct`）、类（`class`）和枚举（`enum`）是三种基本的复合数据类型，它们允许你创建自定义的数据结构。以下是每种类型的简要概述：

### 结构体（Struct）

- 结构体是值类型，它们在传递时被复制，而不是被引用。
- 结构体通常用于表示简单的数据结构，如点（Point）、大小（Size）等。
- 结构体不支持继承，但可以实现协议（Protocols）。
- 结构体有自动生成的成员初始化器（Memberwise Initializers）。

示例：

```swift
struct Point {
    var x: Double
    var y: Double
}

let p = Point(x: 10.0, y: 20.0)
```

### 类（Class）

- 类是引用类型，传递时是通过引用传递的，因此多个变量可以引用同一个类实例。
- 类支持继承，子类可以继承父类的特性，并且可以重写（override）父类的方法。
- 类有析构器（deinitializers），用于在类实例被释放之前执行清理工作。
- 类实例可以使用`deinit`来定义对象被销毁前的清理工作。

示例：

```swift
class Vehicle {
    var numberOfWheels: Int
    
    init(numberOfWheels: Int) {
        self.numberOfWheels = numberOfWheels
    }
    
    func description() -> String {
        return "\(numberOfWheels) wheels"
    }
    
    deinit {
        print("Vehicle is being deinitialized")
    }
}

let myVehicle = Vehicle(numberOfWheels: 4)
print(myVehicle.description())
```

### 枚举（Enum）

- 枚举定义了一组命名的常量值。
- Swift 中的枚举类型非常灵活，它们可以包含原始值类型（如整数、浮点数、字符串）或关联值。
- 枚举还可以包含方法、属性和下标等。

示例：

```swift
enum CompassPoint {
    case north
    case south
    case east
    case west
}

var direction: CompassPoint = .north
switch direction {
case .north:
    print("Heading north")
case .south:
    print("Heading south")
case .east:
    print("Heading east")
case .west:
    print("Heading west")
}
```

### 关联值和原始值

Swift 中的枚举还可以有更高级的用法，如关联值和原始值：

**关联值（Associated Values）** 允许你将额外的值与枚举的成员关联起来：

```swift
enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
```

**原始值（Raw Values）** 允许你将枚举的成员与特定的值（如字符串、字符或整数）相关联：

```swift
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}
```

在这个例子中，`Planet` 枚举的每个成员都关联了一个整数值。未明确赋值的成员会被隐式地赋予后续的值（如 `venus` 会是 2，`earth` 会是 3，以此类推）。

### 枚举是否可以递归？indirect

在 Swift 中，枚举类型（`enum`）本身并不支持传统意义上的“递归”。然而，Swift 提供了 `indirect` 关键字，允许枚举类型存储一个可以递归的数据结构，如树或链表。`indirect` 关键字表明枚举的关联值可以通过引用存储，而不是通过值存储，这对于大型或可变大小的数据结构特别有用。

下面是一个使用 `indirect` 关键字的枚举示例，表示一个简单的二叉树结构：


```swift
indirect enum BinaryTree<T> {
    case empty
    indirect case node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)
}
```
在这个例子中，`BinaryTree` 枚举有两个可能的状态：`empty` 表示一个空的树，而 `node` 表示一个包含值的节点，以及两个子树（左子树和右子树）。由于 `node` 关联值中的 `left` 和 `right` 都是 `BinaryTree<T>` 类型，因此这个枚举是递归的。

请注意，`indirect` 关键字只能用于枚举的 `case`，不能用于枚举本身。它允许关联值通过引用而不是值来存储，这可以避免在存储大型数据结构时产生大量的内存开销。

虽然这不是传统意义上的“递归枚举”，但它允许你使用枚举来表示递归的数据结构。

---------------------------------------------------------------------

### 枚举值原始值和附加值分别是什么？内存占用怎么计算？

在 Swift 中，枚举可以有原始值（Raw Values）和关联值（Associated Values）。这两者是不同的概念，我们分别来看一下：

### 原始值（Raw Values）

原始值是枚举类型在定义时可以为每个枚举成员指定的一个固定值。这个值是与枚举成员相关联的常量，通常用于简化代码和提高可读性。原始值可以是整数、字符串或浮点数等类型。例如：

```swift
enum Direction: String {
    case north = "North"
    case south = "South"
    case east = "East"
    case west = "West"
}
```

在这个例子中，`Direction` 枚举的每个成员都有一个 `String` 类型的原始值。

### 关联值（Associated Values）

关联值是与枚举成员相关联的额外信息，这些信息只在枚举成员被选中时才存在。关联值允许你将额外的数据与特定的枚举成员关联起来。每个枚举成员的关联值类型可以不同。例如：

```swift
enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
```

在这个例子中，`Barcode` 枚举的 `upc` 成员关联了四个整数，而 `qrCode` 成员关联了一个字符串。

### 内存占用计算

枚举的内存占用取决于其关联的值的类型和大小。对于原始值，内存占用通常与所选的原始值类型的大小相对应。例如，如果原始值是 `Int` 类型，那么它将占用与 `Int` 类型相对应的内存空间（在 64 位系统上通常是 8 字节）。

对于关联值，内存占用会更加复杂，因为它取决于与每个枚举成员关联的值的类型和大小。在上面的 `Barcode` 枚举示例中，`upc` 成员将占用与四个整数相对应的内存空间（在 64 位系统上通常是 32 字节），而 `qrCode` 成员将占用与其关联的字符串长度相对应的内存空间（这取决于字符串的长度和编码）。

需要注意的是，Swift 中的枚举在内存中可能还包含一些额外的元数据，用于表示枚举的当前成员和其他信息。这些元数据的确切大小和布局是 Swift 运行时实现的细节，可能会因版本和平台的不同而有所变化。

总的来说，要准确计算枚举的内存占用，需要考虑其原始值或关联值的大小，以及 Swift 运行时可能添加的额外元数据。在大多数情况下，你不需要精确计算枚举的内存占用，除非你在处理大量数据或进行性能优化时需要这些信息。

---------------------------------------------------------------------

### 结构体内存占用如何计算？

在Swift中，结构体的内存占用取决于其包含的属性以及这些属性的类型。每个属性都会占用一定的内存空间，这个空间大小取决于属性的数据类型。下面是一些基本的指导原则来计算结构体的内存占用：

1. **基础数据类型的大小**：
   - 整数类型（如`Int`、`UInt`、`Int8`、`Int16`、`Int32`、`Int64`等）在64位系统上通常占用8字节，在32位系统上占用4字节（但这取决于具体的整数类型，例如`Int8`始终占用1字节）。
   - 浮点类型（如`Float`和`Double`）分别占用4字节和8字节。
   - 布尔类型`Bool`通常占用1字节（尽管在某些情况下，编译器可能会对其进行优化以使用更少的空间）。

2. **复合类型**：
   - 数组、字典、集合等集合类型的内存占用取决于它们包含的元素数量以及每个元素的大小。
   - 字符串`String`的内存占用取决于其编码方式（如UTF-8、UTF-16等）和字符串的长度。
   - 其他结构体或类的实例的内存占用取决于这些实例自身的属性。

3. **内存对齐**：
   - 结构体在内存中的布局可能会因为内存对齐而有所不同。许多处理器在访问特定类型的数据时，要求这些数据在内存中的地址是某个特定数值的倍数，这称为内存对齐。为了满足这个要求，编译器可能会在结构体的字段之间插入填充字节，这会增加结构体的整体大小。

4. **可选类型**：
   - Swift中的可选类型（`Optional`）在内存中实际上是一个枚举，它可以表示有值（`.some(Wrapped)`）或无值（`.none`）。对于非类类型的可选值（如结构体、枚举或基础数据类型），Swift使用一个特殊的内置枚举类型`Optional<Wrapped>`，这可能会增加一些额外的内存开销，尽管这个开销通常很小。

为了得到准确的结构体内存占用大小，你可以使用Swift的`MemoryLayout`结构体，它提供了与类型内存布局相关的信息。例如：

```swift
struct MyStruct {
    var intValue: Int
    var doubleValue: Double
    var boolValue: Bool
}

let size = MemoryLayout<MyStruct>.size // 获取MyStruct结构体的大小
let stride = MemoryLayout<MyStruct>.stride // 获取MyStruct结构体的跨度，包括任何内存对齐所需的额外空间
```

请注意，`MemoryLayout<MyStruct>.size`给出的是结构体在不考虑内存对齐时所需的最小字节数，而`MemoryLayout<MyStruct>.stride`则给出了在考虑内存对齐后结构体实际占用的字节数。在实际分配内存时，通常会使用跨度（stride）而不是大小（size）。

---------------------------------------------------------------------

### 结构体自定义初始化方法和自动生成的初始化方法有什么关系？

在Swift中，结构体（struct）有一个自动生成的成员初始化方法（memberwise initializer），这个方法是根据结构体的属性自动生成的。但是，开发者也可以为结构体定义自定义的初始化方法。这两者之间有一定的关系，但也存在一些区别。

### 自动生成的成员初始化方法

当你定义一个结构体时，Swift会自动为你生成一个成员初始化方法。这个方法允许你按照结构体中定义的属性顺序，为每个属性提供一个初始值，从而创建一个新的结构体实例。例如：

```swift
struct Point {
    var x: Int
    var y: Int
}

// 使用自动生成的成员初始化方法
let p = Point(x: 10, y: 20)
```

在这个例子中，`Point` 结构体有两个属性 `x` 和 `y`，Swift自动生成了一个接受这两个参数的初始化方法。

### 自定义初始化方法

除了自动生成的成员初始化方法外，你还可以为结构体定义自定义的初始化方法。自定义初始化方法允许你以不同的方式初始化结构体的实例，可能包括一些额外的逻辑或默认值的设置。例如：

```swift
struct Point {
    var x: Int
    var y: Int
    
    // 自定义初始化方法
    init(onDiagonal: Int) {
        x = onDiagonal
        y = onDiagonal
    }
}

// 使用自定义初始化方法
let diagonalPoint = Point(onDiagonal: 15)
```

在这个例子中，我们添加了一个名为 `init(onDiagonal:)` 的自定义初始化方法，它允许我们创建一个 `x` 和 `y` 值相等的 `Point` 实例。

### 关系与区别

1. **自动生成与手动定义**：成员初始化方法是自动生成的，而自定义初始化方法需要开发者手动定义。
2. **灵活性**：自定义初始化方法提供了更大的灵活性，允许你根据需要设置默认值、执行额外的逻辑或进行验证。
3. **共存**：自动生成的成员初始化方法和自定义初始化方法可以在同一个结构体中共存。当你定义了一个或多个自定义初始化方法时，自动生成的成员初始化方法仍然可用（除非你显式地定义了一个与成员初始化方法签名完全相同的自定义初始化方法）。
4. **初始化顺序**：在结构体中，所有的存储属性都必须在调用 `self.init` 或返回之前被初始化。自定义初始化方法必须确保所有的属性都被正确地初始化。
5. **替代或补充**：自定义初始化方法并不是用来替代成员初始化方法的，而是作为一种补充，使得结构体的初始化更加灵活和多样化。

总的来说，Swift中的结构体可以拥有自动生成的成员初始化方法和自定义的初始化方法，它们共同为开发者提供了灵活且强大的初始化机制。

---------------------------------------------------------------------

### 结构体能否继承？如果改变property，需要怎么做？mutating

在Swift中，结构体（`struct`）不支持继承。继承是类（`class`）的特性，结构体只能通过组合来复用代码或扩展功能。

关于改变结构体的属性，由于结构体是值类型，当你在方法内部尝试修改它的属性时，你需要使用`mutating`关键字来标记这个方法。`mutating`关键字允许你在不改变结构体实例本身（即不创建新的实例）的情况下，修改它的属性。

下面是一个简单的例子，展示了如何在结构体中使用`mutating`方法来修改属性：

```swift
struct Point {
    var x: Int
    var y: Int
    
    // 初始化方法
    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }
    
    // mutating方法用于修改结构体的属性
    mutating func move(toX x: Int, toY y: Int) {
        self.x = x
        self.y = y
    }
}

var point = Point(x: 0, y: 0)
point.move(toX: 10, toY: 20) // 使用mutating方法来修改point的属性
print("New position: (\(point.x), \(point.y))") // 输出: New position: (10, 20)
```

在这个例子中，`Point`结构体有一个`mutating`方法`move(toX:toY:)`，它允许我们修改结构体的`x`和`y`属性。注意，`mutating`方法只能在变量实例上调用，不能在常量实例上调用，因为常量是不可变的。

由于结构体不支持继承，如果你想要扩展结构体的功能，你可以考虑以下几种方法：

1. **组合**：你可以在一个新的结构体中嵌入现有的结构体作为属性，从而复用其功能。
2. **协议和扩展**：你可以定义协议来描述你想要的功能，并为遵循该协议的类型提供默认实现（通过扩展）。这样，你的结构体可以遵循这个协议，并获得这些默认实现。
3. **泛型**：使用泛型可以让你编写可重用的代码，这些代码可以处理不同类型的数据。虽然这不是继承，但它提供了一种灵活的方式来复用代码逻辑。

---------------------------------------------------------------------

### 类自动生成的初始化方法与结构体自动初始化方法有何区别？

在Swift中，类和结构体在初始化方法上有一些关键的区别，这主要是由于它们是值类型和引用类型的本质差异所导致的。

### 类的初始化方法

类（`class`）是引用类型，并且Swift中的类不自动提供成员初始化方法。开发者需要显式地定义一个或多个初始化方法（也称为构造器）来创建和初始化类的实例。类可以继承，这意味着子类可以继承父类的属性和方法，同时也可以重写或添加新的初始化方法。

例如：

```swift
class MyClass {
    var property: Int
    
    init(property: Int) {
        self.property = property
    }
}

let myClassInstance = MyClass(property: 42)
```

在这个例子中，我们为`MyClass`定义了一个初始化方法，该方法接受一个整数参数并将其赋值给`property`。

### 结构体的初始化方法

结构体（`struct`）是值类型，Swift为结构体自动生成一个成员初始化方法（也称为memberwise initializer），这个初始化方法允许你为结构体的每个存储属性提供一个初始值。由于结构体不支持继承，每个结构体都有其独特的成员初始化方法。

例如：

```swift
struct MyStruct {
    var property: Int
}

let myStructInstance = MyStruct(property: 42)
```

在这个例子中，我们没有显式地定义初始化方法，但Swift为`MyStruct`自动生成了一个成员初始化方法，允许我们创建一个新的结构体实例并初始化其`property`属性。

### 区别总结

1. **自动生成**：结构体有自动生成的成员初始化方法，而类没有。类的初始化方法需要开发者显式定义。
2. **继承**：类可以继承初始化方法（尽管通常需要重写或提供必要的初始化方法以满足子类特定的初始化需求），而结构体不支持继承，因此每个结构体有其独特的自动生成的成员初始化方法。
3. **值类型与引用类型**：结构体是值类型，当你将一个结构体赋值给另一个变量时，实际上是进行了深拷贝。而类是引用类型，赋值操作只是复制了引用，而不是对象本身。这影响了初始化方法的行为和性能考虑。
4. **初始化方法的灵活性**：由于类的初始化方法需要显式定义，因此它们通常更加灵活，可以根据需要执行复杂的设置和配置。而结构体的成员初始化方法相对简单直接，主要用于初始化属性。
5. **去初始化（Deinitialization）**：类可以定义析构器（deinitializer）来处理实例被销毁时的清理工作，而结构体不支持析构器，因为它们的生命周期更加可预测且通常较短。

---------------------------------------------------------------------

### struct 与 class有什么区别？值类型和引用类型，继承，初始化方法，属性值改变

在Swift中，`struct`（结构体）和`class`（类）是两种不同类型的复合数据类型，它们之间有几个关键的区别。以下是关于它们的主要差异：

1. **值类型与引用类型**：
   - `struct`是值类型（Value Type）。当你将一个结构体实例赋值给另一个变量时，会创建一个该实例的完整拷贝。这意味着对拷贝的修改不会影响原始实例。
   - `class`是引用类型（Reference Type）。当你将一个类实例赋值给另一个变量时，实际上你复制的是指向该实例的引用，而不是实例本身。因此，通过任何一个引用对实例所做的修改都会反映在所有引用上。

2. **继承**：
   - `struct`不支持继承。每个结构体都是独立的，不能从其他结构体继承属性或方法。
   - `class`支持继承。一个类可以继承另一个类的属性和方法，从而实现代码的重用和扩展。

3. **初始化方法**：
   - 对于`struct`，Swift会自动生成一个成员初始化方法（memberwise initializer），允许你按照结构体中定义的属性顺序，为每个属性提供一个初始值，从而创建一个新的结构体实例。此外，你也可以自定义初始化方法来满足特定需求。
   - 对于`class`，初始化方法需要显式定义。类可以有多个初始化方法，包括指定初始化方法和便利初始化方法。子类在继承父类时必须满足父类的初始化要求。

4. **属性值改变**：
   - 在`struct`中，由于它是值类型，当你想要修改结构体的属性时，你需要使用`mutating`关键字来标记修改属性的方法。这是因为值类型的实例在方法内部默认是不可变的。
   - 在`class`中，由于它是引用类型，你可以直接在类的实例上修改属性，而无需使用`mutating`关键字。

综上所述，`struct`和`class`在Swift中有着不同的使用场景和优势。选择使用哪一种取决于你的具体需求，例如是否需要继承、是否希望实例在赋值时保持独立等。通常，对于简单的数据结构或需要保持值语义的情况，使用`struct`更为合适；而对于需要继承、多态或动态派发的复杂对象，则使用`class`更为恰当。

---------------------------------------------------------------------

### 如何给结构体，类，枚举增加subscript下标？subscript可以用来做什么？

在Swift中，你可以给结构体、类和枚举定义下标（subscript），以便使用下标语法来访问这些类型的实例。下标允许你像访问数组或字典元素一样访问自定义类型的成员。

下标可以用来：

- 提供一个简洁的方式来访问集合类型或复杂数据结构的元素。
- 抽象数据的内部表示，让用户可以以更简单、更直观的方式来操作数据。
- 为自定义类型创建类似数组或字典的访问方式。

以下是如何在Swift中为结构体、类和枚举增加subscript的示例：

### 结构体（Struct）中的下标

```swift
struct Matrix {
    let rows: Int, columns: Int
    var grid: [Double]
    
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        grid = Array(repeating: 0.0, count: rows * columns)
    }
    
    subscript(row: Int, column: Int) -> Double {
        get {
            return grid[(row * columns) + column]
        }
        set {
            grid[(row * columns) + column] = newValue
        }
    }
}
```

### 类（Class）中的下标

```swift
class MyClass {
    private var elements: [String] = ["Element 1", "Element 2", "Element 3"]
    
    subscript(index: Int) -> String {
        get {
            return elements[index]
        }
        set(newValue) {
            elements[index] = newValue
        }
    }
}
```

### 枚举（Enum）中的下标（虽然不常见，但可以通过关联值实现类似功能）

枚举通常不直接支持下标，因为它们代表一组固定的值。但是，你可以通过关联值（associated values）来模拟下标访问。

```swift
enum MyEnum {
    case first(String)
    case second(String, String)
    case third([String])
    
    var description: String {
        switch self {
        case .first(let value):
            return value
        case .second(let first, _):
            return first
        case .third(let values):
            return values.joined(separator: ", ")
        }
    }
    
    subscript(index: Int) -> String? {
        switch self {
        case .third(let values):
            return index < values.count ? values[index] : nil
        default:
            return nil
        }
    }
}

let myValue = MyEnum.third(["Apple", "Banana", "Cherry"])
print(myValue[1]) // 输出 "Banana"
```

在这个枚举的例子中，我们为`.third`情况添加了一个模拟的下标。当然，这只是一个演示，并不是枚举的典型用法。在实际应用中，你应该仔细考虑是否真的需要在枚举中使用下标。

总的来说，下标提供了一种灵活的方式来访问和操作自定义类型中的数据，使得这些类型更加易用和直观。

---------------------------------------------------------------------

## 4、swift方法、闭包

Swift 方法（或函数）和闭包（Closures）是 Swift 语言中处理逻辑和行为的两个重要概念。下面我会详细解释这两个概念。

### Swift 方法（或函数）

在 Swift 中，方法是与特定类型相关联的函数。对于类、结构体和枚举，你可以定义实例方法或类方法。实例方法是与类型的实例相关联的方法，而类方法是与类型本身相关联的方法，而不是其实例。

#### 实例方法

实例方法是与类、结构体或枚举的实例相关联的方法。你可以通过该实例来调用这些方法。


```swift
class MyClass {
    func myInstanceMethod() {
        print("This is an instance method.")
    }
}

let myObject = MyClass()
myObject.myInstanceMethod() // 输出: "This is an instance method."
```
#### 类方法

类方法是与类、结构体或枚举本身相关联的方法，而不是其实例。你可以通过类型名称直接调用这些方法。


```swift
class MyClass {
    class func myTypeMethod() {
        print("This is a type method.")
    }
}

MyClass.myTypeMethod() // 输出: "This is a type method."
```
### 闭包（Closures）

闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的块（blocks）以及其他一些编程语言中的匿名函数或 lambda 函数类似。

闭包可以捕获和存储其所在上下文中定义的任何常量和变量的引用。这就是所谓的“闭包”特性，因为这些常量和变量被“封闭”在闭包内部，使得闭包可以记住并访问它们，即使在闭包原始作用域之外。

下面是一个简单的闭包示例：


```swift
let numbers = [1, 2, 3, 4, 5]

let mappedNumbers = numbers.map { (number: Int) -> Int in
    return number * 2
}

print(mappedNumbers) // 输出: [2, 4, 6, 8, 10]
```
在这个例子中，`map` 函数接受一个闭包作为参数，该闭包对数组中的每个元素执行某种操作，并返回一个新的数组。这里的闭包是一个简单的匿名函数，它接受一个整数参数并返回该整数的两倍。

闭包在 Swift 中非常有用，因为它们可以作为参数传递给其他函数，也可以作为函数的返回值。这使得代码更加灵活和可重用。

### 实例方法和类方法有什么区别？

在Swift中，实例方法和类方法之间的主要区别体现在它们与类及其实例的关联方式上，以及它们的用途和行为。以下是具体的区别：

1. **关联方式**：
   - **实例方法**：与类的特定实例相关联。这意味着你必须先创建类的一个实例（对象），然后通过这个实例来调用该方法。
   - **类方法**：与类本身相关联，而不是与类的任何特定实例相关联。因此，你可以直接通过类名来调用类方法，而无需创建类的实例。

2. **用途**：
   - **实例方法**：通常用于操作或查询与特定对象实例相关的状态或执行与特定实例相关的行为。例如，一个表示银行账户的类可能有一个实例方法来查询账户余额或进行转账。
   - **类方法**：通常用于执行与类本身相关的操作，而不是与类的任何特定实例相关的操作。例如，一个工具类可能提供一个类方法来执行某些静态计算或返回类的某些通用信息。

3. **访问权限和状态**：
   - **实例方法**：可以自由地访问和修改其所属实例的属性和其他实例方法。它们也可以调用类方法和类属性，但通常不能直接修改它们（除非这些类成员被设计为可变的）。
   - **类方法**：不能直接访问实例属性和实例方法，因为它们不与任何特定实例相关联。但是，它们可以访问和修改类级别的属性和方法（即类属性和类方法）。

4. **语法**：
   - **实例方法**：在类定义中直接定义，不需要任何特殊关键字。调用时需要先创建对象实例，然后通过该实例调用方法。
   - **类方法**：在类定义中使用`class`关键字来声明。调用时直接使用类名加方法名的方式。

5. **继承和重写**：
   - **实例方法**：可以被子类继承和重写（override），除非它们被标记为`final`。
   - **类方法**：同样可以被子类继承和重写，但子类在重写类方法时也必须使用`class`关键字。

6. **生命周期**：
   - **实例方法**：与对象实例的生命周期相关联。当对象被销毁时，其上的实例方法也不再可用。
   - **类方法**：与类本身的生命周期相关联，因此只要类在内存中可用，类方法就可用。

总的来说，实例方法和类方法在Swift中各自扮演着不同的角色，并根据需要执行与实例相关或与类相关的操作。

---------------------------------------------------------------------

### 值类型的属性想要被自身的实例方法修改，怎么实现？mutating

在Swift中，值类型（如结构体和枚举）的实例默认情况下是不能修改它们自身的属性的，因为这些类型是不可变的。但是，Swift 提供了一个关键字 `mutating`，它允许在值类型的实例方法内部修改该实例的属性。

当你为值类型定义一个`mutating`方法时，该方法可以在调用时修改该实例的属性。这是通过在该方法内部创建一个该值类型的新实例，并用修改后的属性值初始化它，然后将这个新实例替换原始实例来实现的。

下面是一个简单的示例，展示了如何使用`mutating`方法修改结构体的属性：

```swift
struct Point {
    var x: Int
    var y: Int
    
    // 使用 mutating 关键字允许此方法修改结构体的属性
    mutating func move(dx: Int, dy: Int) {
        x += dx
        y += dy
    }
}

var point = Point(x: 0, y: 0)
point.move(dx: 5, dy: 10)
print(point) // 输出：Point(x: 5, y: 10)
```

在这个例子中，`Point` 是一个结构体，它有两个属性 `x` 和 `y`。`move(dx:dy:)` 方法被标记为 `mutating`，因此它能够在方法内部修改 `x` 和 `y` 的值。当我们调用 `point.move(dx: 5, dy: 10)` 时，`point` 的 `x` 和 `y` 属性分别增加了5和10。

请注意，`mutating` 关键字仅适用于值类型（结构体和枚举）。引用类型（如类）的实例方法默认就可以修改实例的属性，因此不需要（也不能）使用 `mutating` 关键字。

---------------------------------------------------------------------

### 什么是闭包？闭包表达式是怎么样的？

在Swift中，闭包（Closure）是自包含的代码块，它可以被传递和使用，类似于C或Objective-C中的块（block）或者其它一些编程语言中的匿名函数。闭包可以捕获和存储其所在上下文中定义的任何常量和变量的引用。这就是它们被称为“闭包”的原因，因为它们可以“封闭”周围的上下文环境。

Swift的闭包表达式语法灵活且富有表现力，它们可以采取几种不同的形式。以下是闭包表达式的基本语法：


```swift
{ (parameters) -> returnType in
    statements
}
```
这里的`parameters`表示闭包的参数列表，`returnType`是闭包返回值的类型，`statements`是执行具体操作的代码块。

举个例子，以下是一个简单的闭包，它接受两个整数参数并返回它们的和：


```swift
let addTwoNumbers: (Int, Int) -> Int = { (a, b) -> Int in
    return a + b
}
```
在这个例子中，`addTwoNumbers`是一个闭包，它接受两个整数作为参数，并返回它们的和。`(Int, Int) -> Int`定义了闭包的类型：它接受两个Int类型的参数，并返回一个Int类型的结果。在大括号内，我们定义了闭包的具体行为，即返回两个参数的和。

在实际使用中，Swift的类型推断功能可以让我们省略闭包的参数类型和返回类型，所以上述闭包可以简化为：


```swift
let addTwoNumbers = { (a, b) in
    return a + b
}
```
甚至更简洁，如果闭包的主体只有一条返回语句，我们可以使用隐式返回（即省略`return`关键字）：


```swift
let addTwoNumbers = { (a, b) in a + b }
```

---------------------------------------------------------------------

### 闭包作为参数时的缩写？什么是尾随闭包?

**闭包作为参数时的缩写：**

在Swift中，当闭包作为参数传递时，可以使用缩写形式来简化代码。这种缩写主要包括省略参数类型和括号，甚至可以省略`return`关键字。此外，还可以使用参数名称缩写，例如`$0`代表第一个参数，`$1`代表第二个参数，以此类推。这些缩写使得闭包作为参数时更加简洁和易读。

**尾随闭包（Trailing Closure）：**

尾随闭包是Swift中的一种语法特性，它允许将一个闭包表达式作为函数的最后一个参数，并且将该闭包写在函数调用的括号之外。这种做法可以使得代码更加清晰和易于阅读。尾随闭包特别适用于那些闭包表达式很长或者很复杂的情况，因为它可以避免在函数调用中嵌入大量的代码。

例如，如果我们有一个接受闭包作为参数的函数，我们可以这样使用尾随闭包：


```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // 函数实现
}

// 使用尾随闭包的调用方式
someFunctionThatTakesAClosure {
    // 闭包的具体实现
}
```
在这个例子中，闭包被写在了函数调用的括号之外，这就是尾随闭包的写法。注意，当使用尾随闭包时，如果函数的最后一个参数是闭包，那么我们甚至可以省略该参数的标签。

---------------------------------------------------------------------

### @autoclosure是什么？有什么作用？

---------------------------------------------------------------------

### Swift函数定义，函数重载，函数类型

---------------------------------------------------------------------

## 5、Swift属性，单例

### 什么是计算属性，什么是存储属性？只读计算属性，延迟存储属性呢？

---------------------------------------------------------------------

### 枚举的原始值属于计算属性还是存储属性？

---------------------------------------------------------------------

### 什么是属性观察器？willSet，didSet

---------------------------------------------------------------------

### 实例属性和类型属性有什么区别？

---------------------------------------------------------------------

### Swift单例如何实现？

---------------------------------------------------------------------

### 存储类型属性有什么特点? 在什么时候初始化？多个线程同时访问呢？

---------------------------------------------------------------------

## 6、swift 泛型，关联类型，协议类型，不透明类型

### 泛型有什么作用？类型参数化

---------------------------------------------------------------------

### 什么是关联类型？有什么作用？给协议中用到的类型定义一个占位名称

---------------------------------------------------------------------

### 什么是协议类型，协议类型能否作为函数返回值？

---------------------------------------------------------------------

### 泛型类型如何约束？

---------------------------------------------------------------------

### 什么是不透明类型？some限制只能返回一种类型

---------------------------------------------------------------------

## 7、swift运算符

### 什么是溢出运算符？

---------------------------------------------------------------------

### 什么是运算符重载？

---------------------------------------------------------------------

### Equatable协议与==运算符有什么关系？Swift为哪些类型提供默认的 Equatable 实现？

---------------------------------------------------------------------

### 如何自定义新的运算符？全局作用域使用operator进行声明

---------------------------------------------------------------------

## 8、Swift初始化器

### 指定初始化器和便捷初始化器有什么区别？required

---------------------------------------------------------------------

### 重写父类指定初始化器和便捷初始化器有何区别？

---------------------------------------------------------------------

### 初始化器自动继承的规则？

---------------------------------------------------------------------

### 初始化器中赋值会触发属性观察器么？

---------------------------------------------------------------------

### 什么是反初始化器？deinit

---------------------------------------------------------------------

## 9、Swift内存管理

### swift 中内存管理方案？ARC引用类型有几种？strong、weak、unowned

---------------------------------------------------------------------

### Swift闭包循环引用如何产生，怎么解决？

---------------------------------------------------------------------

### 能否在定义闭包属性的同时引用self？lazy

---------------------------------------------------------------------

### 如果lazy属性是闭包调用的结果，是否需要考虑循环引用问题？

---------------------------------------------------------------------

### 什么是逃逸闭包?逃逸闭包能否捕获inout参数？@escaping

---------------------------------------------------------------------

### 什么是内存访问冲突？Conflicting Access to Memory

---------------------------------------------------------------------

### Swift中指针类型有哪几种？

---------------------------------------------------------------------

## 10、Swift扩展

### Swift中扩展与OC中分类有什么区别？能添加什么，不能添加什么？

---------------------------------------------------------------------

### Swift中扩展不能添加指定初始化器，不能添加反初始化器

---------------------------------------------------------------------

### 结构体自定义初始化器时不会生成默认初始化器。但是可以通过扩展实现两者同时存在

---------------------------------------------------------------------

### 扩展可以给协议提供默认实现，也间接实现可选协议的效果

---------------------------------------------------------------------

### 扩展可以给协议扩充协议中从未声明过的方法

---------------------------------------------------------------------

### 扩展中依然可以使用原类型中的泛型类型

---------------------------------------------------------------------

## 11、Swift继承

### 值类型并不支持继承，只有类支持继承

---------------------------------------------------------------------

### swift中是否有类似NSObject的基类？

---------------------------------------------------------------------

### Swift如何重写父类的下标、方法、属性？override

---------------------------------------------------------------------

### 如何限制不能被重写，或者不能被继承？final

---------------------------------------------------------------------

### 是否可以重写存储属性？

---------------------------------------------------------------------

### let修饰的属性能否重写？

---------------------------------------------------------------------

### static修饰的属性能否被重写？

---------------------------------------------------------------------

## 12、Swift模式匹配

### 什么是模式匹配？

---------------------------------------------------------------------

### 什么是通配符模式？标识符模式？值绑定模式？元组模式？枚举Case模式？可选模式？类型转换模式？表达式模式？

---------------------------------------------------------------------

### 通配符匹配中_和_?有什么区别？

---------------------------------------------------------------------

### 枚举Case模式中if case语句是什么？

---------------------------------------------------------------------

## 13、Swift协议与面向协议编程,协议实现前缀

### 什么是协议？协议能添加什么？

---------------------------------------------------------------------

### 协议中定义的内容是否必须全部都实现？如果想要实现可选协议呢？

---------------------------------------------------------------------

### 实现协议时的属性权限要不小于协议中定义的属性权限

---------------------------------------------------------------------

### 协议中定义的init方法，能否用init?来实现？

---------------------------------------------------------------------

### 枚举值如何进行遍历？遵守CaseIterable协议

---------------------------------------------------------------------

### 自定义打印需要遵循什么协议？CustomStringConvertible、 CustomDebugStringConvertible

---------------------------------------------------------------------

### Any、AnyObject有什么区别？如何定义只能类遵守的协议？

---------------------------------------------------------------------

### 什么是面向协议编程？解决了面向对象编程哪些问题？

---------------------------------------------------------------------

### 如何利用协议实现前缀效果？

---------------------------------------------------------------------

## 14、Swift访问控制

### Swift访问控制有哪几种访问级别？分别是什么？open，public，internal，fileprivate，private

---------------------------------------------------------------------

### 访问级别的使用准则？一个实体不可以被更低访问级别的实体定义

---------------------------------------------------------------------

### 元组类型，泛型类型的访问级别如何确定？

---------------------------------------------------------------------

### 类型的访问级别对其成员，嵌套类型的影响？

---------------------------------------------------------------------

### 子类重写成员的访问级别有什么限制？ ≥ 子类的访问级别，或者 ≥ 父类被重写成员的访问级别

---------------------------------------------------------------------

### 协议定义的方法，枚举类型的case等是否能单独设置访问级别？

---------------------------------------------------------------------

### public类的默认初始化器是internal级别。如果一个public类想在另一个模块调用编译生成的默认无参初始化器，必须显式提供public的无参初始化器

---------------------------------------------------------------------

## 15、swift 错误处理

### 如何自定义错误？遵守Error协议

---------------------------------------------------------------------

### 如何抛出异常，如何捕获异常？throw，do-catch

---------------------------------------------------------------------

### 可以使用try?、try!调用可能会抛出Error的函数，这样就不用去处理Error

---------------------------------------------------------------------

### 如何定义以任何方式（抛错误、return等）离开代码块前必须要执行的代码？defer

---------------------------------------------------------------------

### fatalError有作用？可以做什么？

---------------------------------------------------------------------

## 16、swift与OC

### MARK、TODO、FIXME

---------------------------------------------------------------------

### Swift条件编译？

---------------------------------------------------------------------

### Swift与OC互相调用？

---------------------------------------------------------------------

### Swift中String与NSString有什么区别？

---------------------------------------------------------------------

### 如何让Swift内容具有动态性？@objc dynamic

---------------------------------------------------------------------

### Swift资源名如何管理？